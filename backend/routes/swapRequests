const express = require("express");
const { getFirestore } = require("firebase-admin/firestore");
const { verifyToken } = require("../middleware/authMiddleware");

const router = express.Router();
const db = getFirestore();

// Create a swap request
// POST /api/swap-requests
router.post("/", verifyToken, async (req, res) => {
    try {
        const { 
            targetListingId, 
            offeredListingId, 
            requestType, // 'swap' or 'buy'
            message 
        } = req.body;

        const userId = req.user.uid || req.user.claims?.user_id || req.user.user_id;

        if (!targetListingId || !requestType) {
            return res.status(400).json({ 
                error: "Missing required fields (targetListingId, requestType)" 
            });
        }

        // If swap, offeredListingId is required
        if (requestType === 'swap' && !offeredListingId) {
            return res.status(400).json({ 
                error: "Offered listing is required for swap requests" 
            });
        }

        // Get target listing to find the owner
        const targetListingDoc = await db.collection("listings").doc(targetListingId).get();
        if (!targetListingDoc.exists) {
            return res.status(404).json({ error: "Target listing not found" });
        }

        const targetListing = targetListingDoc.data();
        const targetUserId = targetListing.userId;

        // Prevent requesting own listings
        if (targetUserId === userId) {
            return res.status(400).json({ 
                error: "You cannot request your own listing" 
            });
        }

        // Build swap request object
        const swapRequest = {
            requesterId: userId,
            targetUserId: targetUserId,
            targetListingId,
            offeredListingId: offeredListingId || null,
            requestType,
            message: message || "",
            status: "pending", // pending, accepted, rejected, cancelled
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        const docRef = await db.collection("swapRequests").add(swapRequest);

        return res.status(201).json({ 
            id: docRef.id, 
            ...swapRequest 
        });
    } catch (err) {
        console.error("Error creating swap request:", err);
        return res.status(500).json({ 
            error: "Failed to create swap request", 
            details: err.message 
        });
    }
});

// Get swap requests sent by current user
// GET /api/swap-requests/sent
router.get("/sent", verifyToken, async (req, res) => {
    try {
        const userId = req.user.uid || req.user.claims?.user_id || req.user.user_id;

        const snapshot = await db.collection("swapRequests")
            .where("requesterId", "==", userId)
            .orderBy("createdAt", "desc")
            .get();

        const requests = await Promise.all(snapshot.docs.map(async (doc) => {
            const requestData = { id: doc.id, ...doc.data() };
            
            // Fetch target listing details
            const targetListing = await db.collection("listings").doc(requestData.targetListingId).get();
            requestData.targetListing = targetListing.exists ? { id: targetListing.id, ...targetListing.data() } : null;

            // Fetch offered listing details if exists
            if (requestData.offeredListingId) {
                const offeredListing = await db.collection("listings").doc(requestData.offeredListingId).get();
                requestData.offeredListing = offeredListing.exists ? { id: offeredListing.id, ...offeredListing.data() } : null;
            }

            return requestData;
        }));

        res.json(requests);
    } catch (err) {
        console.error("Error fetching sent requests:", err);
        res.status(500).json({ error: "Failed to fetch sent requests" });
    }
});

// Get swap requests received by current user
// GET /api/swap-requests/received
router.get("/received", verifyToken, async (req, res) => {
    try {
        const userId = req.user.uid || req.user.claims?.user_id || req.user.user_id;

        const snapshot = await db.collection("swapRequests")
            .where("targetUserId", "==", userId)
            .orderBy("createdAt", "desc")
            .get();

        const requests = await Promise.all(snapshot.docs.map(async (doc) => {
            const requestData = { id: doc.id, ...doc.data() };
            
            // Fetch target listing details
            const targetListing = await db.collection("listings").doc(requestData.targetListingId).get();
            requestData.targetListing = targetListing.exists ? { id: targetListing.id, ...targetListing.data() } : null;

            // Fetch offered listing details if exists
            if (requestData.offeredListingId) {
                const offeredListing = await db.collection("listings").doc(requestData.offeredListingId).get();
                requestData.offeredListing = offeredListing.exists ? { id: offeredListing.id, ...offeredListing.data() } : null;
            }

            // Fetch requester info
            const requesterDoc = await db.collection("users").doc(requestData.requesterId).get();
            requestData.requester = requesterDoc.exists ? { id: requesterDoc.id, ...requesterDoc.data() } : null;

            return requestData;
        }));

        res.json(requests);
    } catch (err) {
        console.error("Error fetching received requests:", err);
        res.status(500).json({ error: "Failed to fetch received requests" });
    }
});

// Update swap request status (accept/reject)
// PATCH /api/swap-requests/:id
router.patch("/:id", verifyToken, async (req, res) => {
    try {
        const { id } = req.params;
        const { status, contactInfo } = req.body;
        const userId = req.user.uid || req.user.claims?.user_id || req.user.user_id;

        if (!["accepted", "rejected", "cancelled"].includes(status)) {
            return res.status(400).json({ 
                error: "Invalid status. Must be 'accepted', 'rejected', or 'cancelled'" 
            });
        }

        const requestDoc = await db.collection("swapRequests").doc(id).get();
        if (!requestDoc.exists) {
            return res.status(404).json({ error: "Swap request not found" });
        }

        const requestData = requestDoc.data();

        // Only target user can accept/reject, only requester can cancel
        if (status === "cancelled" && requestData.requesterId !== userId) {
            return res.status(403).json({ error: "Unauthorized to cancel this request" });
        }
        if ((status === "accepted" || status === "rejected") && requestData.targetUserId !== userId) {
            return res.status(403).json({ error: "Unauthorized to update this request" });
        }

        const updateData = {
            status,
            updatedAt: new Date().toISOString()
        };

        // If accepting, store contact info
        if (status === "accepted" && contactInfo) {
            updateData.contactInfo = contactInfo;
        }

        await db.collection("swapRequests").doc(id).update(updateData);

        res.json({ 
            id, 
            ...requestData, 
            ...updateData 
        });
    } catch (err) {
        console.error("Error updating swap request:", err);
        res.status(500).json({ 
            error: "Failed to update swap request", 
            details: err.message 
        });
    }
});

// Delete/cancel a swap request
// DELETE /api/swap-requests/:id
router.delete("/:id", verifyToken, async (req, res) => {
    try {
        const { id } = req.params;
        const userId = req.user.uid || req.user.claims?.user_id || req.user.user_id;

        const requestDoc = await db.collection("swapRequests").doc(id).get();
        if (!requestDoc.exists) {
            return res.status(404).json({ error: "Swap request not found" });
        }

        const requestData = requestDoc.data();

        // Only requester can delete
        if (requestData.requesterId !== userId) {
            return res.status(403).json({ error: "Unauthorized to delete this request" });
        }

        await db.collection("swapRequests").doc(id).delete();

        res.json({ message: "Swap request deleted successfully" });
    } catch (err) {
        console.error("Error deleting swap request:", err);
        res.status(500).json({ 
            error: "Failed to delete swap request", 
            details: err.message 
        });
    }
});

module.exports = router;